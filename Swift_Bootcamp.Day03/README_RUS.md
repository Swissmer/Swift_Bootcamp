### Привет!

В этом проекте рассматриваются следующие темы:

- Generics - классы, которые могут иметь параметры типа. С их помощью можно написать класс или метод, который будет работать не с конкретными, а с произвольными типами данных: тип (или иерархия типов) будет определяться разработчиком в контексте использования. В то же время инструмент обеспечивает безопасность типов: после указания типа или иерархии типов работа с этим дженериком происходит только в контексте указанного типа.
- Lazy инициализация. Существуют ситуации, когда создание переменных не должно происходить в момент начала использования класса. Ленивые переменные позволяют создать объект в момент первого его вызова. Также это может помочь оптимизировать код и вычисления.
- Функциональные типы. Безусловно, работа с ними заслуживает внимания. Разработчики предусмотрели отличную поддержку этого популярного инструмента, а также добавили несколько удобных конструкций для выполнения задач в контексте объекта.

## Темы:
- Дженерики
- Subscript
- Ленивая инициализация
- Делегаты

**Совет!** Перед тем, как выполнять задания, посмотри примеры в [документации](https://docs.swift.org/swift-book/LanguageGuide/Generics.html), где представлено несколько пример возможно использования дженериков.

### Проект: утилиты для создания игр

## Задания:

**Требование!** Создай workspace внутри папки src с названием day03.
Для каждой задачи внутри workspace необходимо создать macOS/Command Line Tool проект. Например, day03/quest1, day03/quest2.
Также не забудь при создании проекта в пункте `Add to:` выбрать созданный workplace.
Более подробное описание о создании проектов можно прочитать в [документации](https://www.swift.org/getting-started/).

### Задание 1. Мир дикого запада
Требуется описать класс, моделирующий револьвер. 
В данном задании это типизированный класс. 
Обойма револьвера содержит элемент в соответствии с объявленным типом. 
Например, RevolverMoonClip<Int> будет хранить элементы типа `Int`.

- Обойма револьвера представляет собой массив из 6 элементов. Если слот пустой, то там должен храниться `nil`.
- Ты можешь добавить один элемент в ближайший свободный слот методом `add()`. При успешном добавлении возвращается true, иначе - false.
- Возможно добавление путем списка элементов. Функция принимает другую коллекцию, как ресурс, из которого добавляются все элементы в обойму. Если элементов в коллекции недостаточно, то заполняется объект револьвера настолько, насколько возможно. Если список пустой, метод возвращает false.
- Класс имеет свойство `pointer`. С его помощью ты сможешь получать текущий элемент на курке. Таковым является элемент в обойме с индексом 0.
- Ты можешь удалять элементы одним за одним при помощи метода стрельбы `shoot()`, который возвращает удаленный элемент. Удаление начинается с элемента `pointer`.
- Ты можешь вызывать `unloadAll()` для всех элементов разом или `unload(index)` для извлечения одного. Функция возвращает извлеченный элемент либо список всех элементов.
- Ты можешь прокрутить обойму методом `scroll()`, меняя позицию pointer на случайный элемент. Последовательность элементов между собой должна сохраниться, при этом элемент на курке должен поменяться.
- Добавь метод getSize(), который возвращает количество элементов в револьвере.
- Создай функцию расширения `toStringDescription()` для класса, которая будет представлять информацию об объекте класса и его элементах в виде `String`. Информация об элементах записывается, начиная с позиции элемента на курке (pointer).
- У класса должен корректно работать оператор сравнения `==`. Переопредели его при помощи протокола `Equatable`. Объекты класса эквивалентны, если имеют одинаковое сочетание элементов, начиная с любой позиции, включая nil. Пример сравнения представлен ниже. 
- Сделай для класса метод `subscript(index: Int`). Он будет возвращать для любого револьвера при обращении по индексу элемент, который находится на данной позиции в обойме. Если индекс больше чем число элементов в обойме, то происходит ошибка.

**Проверь результат:** напиши программу, которая показывает, как работает класс `RevolverMoonClip`, и запусти ее
1. Создай объект револьвера, заполнив его при помощи конструктора максимальным количеством элементов. Выведи в консоль описание класса типа `RevolverMoonClip<Type>`, содержимое обоймы, начиная с `pointer` и сам `pointer`.
2. Получи первый и последний элемент в обойме при помощи `subscript`, вызвав индексы соответствующих элементов.
3. Вызови метод `scroll` и выведи объект консоль. Результат должен начинаться с другого элемента (но он может быть равным по значению). Порядок между элементами должен сохраняться.
4. Удали 4 элемента один за другим. Напечатай объект класса и сравни с предыдущим выводом. Измененная обойма должна начинаться с 5-ого элемента, за ним должен идти тот же элемент, что и до этого, затем 4 значения `nil`.
5. Создай коллекцию из 8 элементов того же типа, что и дженерик созданного объекта. Добавь эту коллекцию в револьвер и выведи сравнение старой и новой коллекции в револьвере. Обойма должна заполняться полностью первыми 4 элементами из коллекции. `pointer` устанавливается при каждом добавлении на заполненный элемент обоймы.
6. Вытащи все элементы класса `unloadAll`. Напечатай размер вытащенного списка и размер объекта (должно быть 6 и 0) 
7. Добавь 4 элемента `supply` в коллекцию объекта класса. Размер обоймы револьвера должен стать 4.
8. Создай новый объект с теми же элементами, как в полученном выше списке. Также необходимо сделать предварительный scroll. Далее сопоставь при помощи оператора `==` эквивалентны ли эти объекты. Результат операции должен быть true.

_Пример вывода программы_
```
1. Adding elements
Structure: RevolverMoonClip<Int> 
Objects: [3, 54, 7, 2, 56, 4]
Pointer: 3

2. Subscript
3, 4

3. Scroll
Structure: RevolverMoonClip<Int> 
Objects: [7, 2, 56, 4, 3, 54]
Pointer: 7

4. Deletion
Structure: RevolverMoonClip<Int> 
Objects: [3, 54, nil, nil, nil, nil]
Pointer: 3

5. Supply collection
Before: 
Supply collection: [4, 6, 3, 22, 77, 43, 76, 5]

Structure: RevolverMoonClip<Int> 
Objects: [3, 54, nil, nil, nil, nil]
Pointer: 3

After add operation performed:
Structure: RevolverMoonClip<Int> 
Objects: [22, 3, 6, 4, 3, 54]
Pointer: 22

6. Extraction
The extracted list: [22, 54, 6, 4, 3, 54]
size: 6

Structure: RevolverMoonClip<Int> 
Objects: [nil, nil, nil, nil, nil, nil]
Pointer: nil
size: 0

7. Supply collection 2
Before:
Supply collection: [77, 43, 76, 5]

Structure: RevolverMoonClip<Int> 
Objects: [nil, nil, nil, nil, nil, nil]
Pointer: nil

After add operation performed:
Structure: RevolverMoonClip<Int> 
Objects: [5, 76, 43, 77, nil, nil]
Pointer: 5

8. Equals
Structure: RevolverMoonClip<Int> 
Objects: [nil, 5, 76, 43, 77, nil]
Pointer: nil

Structure: RevolverMoonClip<Int> 
Objects: [nil, nil, 5, 76, 43, 77]
Pointer: nil

Result: equals
```

### Задание 2. Патроны
Требуется описать классы для работы с патронами в револьвере.

**Патрон:**
- Создай класс для патрона (Patron)
- Также здесь нужно добавить поля для описания патрона (холостой или заряженный)
- Для уникальности патронов можешь использовать класс `UUID`
- Патрон должен содержать свойство калибра (например - 22, 38, 45)
- Класс должен иметь свой метод `shoot()` с выводом «Bang» и информации о калибре

**Обновление содержания класса револьвера:**
- Добавь свойство калибра для револьвера
- Сделай так, что револьвер работал только с типом `Patron`. Ты не можешь класть патроны разных калибров в одну обойму. Убери типизацию из класса.
- При вызове `shoot()` соответствующий вызов должен происходит и у патронов. Однако, если патрон холостой, то shoot у его класса вызывать не нужно. 
- Если происходит выстрел при пустой ячейке, программа выводит «Click»

**Представление соответствующей логики для классов револьвера и патронов:**
  - Патрон может быть только в одной обойме револьверов. Если ты пытаешься добавить патрон, который уже есть в другой обойме, метод револьвера `add` должен возвращать false. Также, если ты добавляешь коллекцию патронов, то подобный патрон должен быть проигнорирован, а остальные добавлены. Аналогично для патронов, не совпадающих калибром с револьвером.
  - Каждый патрон может быть использован для заряженного выстрела лишь раз. Если патрон холостой, он выпадет из револьвера, но выстрел не произойдет. Револьвер не должен вызывать метод стрельбы у патрона, но печатает «Click», аналогично выстрелу из пустой ячейки.

**Проверка результата:** для проверки создай программу, которая делает следующее. 
- Проверь, что заряженные патроны стреляют, а холостые нет
- Попробуй добавить патрон в разные револьверы. При первичном добавлении вернется true, вторичном - false. Предварительно создай 2 пустых револьвера.
- Попробуй добавить патрон в две разные коллекции. И попробуй добавить эти коллекции в два разных револьвера. Предварительно создай 2 пустых револьвера.

_Пример вывода программы_
```
1. Shoot or damp
Structure: RevolverMoonClip 32 caliber
Objects: [Patron(id1, charged, 32), Patron(id2, damp, 32), nil, nil, nil, nil]
Pointer: Patron(id1, charged, 32)

Shoot # call shoot()
Bang 32

Structure: RevolverMoonClip 32 caliber
Objects: [Patron(id2, damdp, 32), nil, nil, nil, nil, nil]
Pointer: Patron(id2, damp, 32)

Shoot 
Click
Objects: [nil, nil, nil, nil, nil, nil]
Pointer: nil

2. Unique Patron
Patron(id, charged, 32)

Revolver1: [nil, nil, nil, nil, nil, nil]
Revolver2: [nil, nil, nil, nil, nil, nil]

Add1 # call add()
Revolver1: [Patron(id, charged, 32), nil, nil, nil, nil, nil]
Revolver2: [nil, nil, nil, nil, nil, nil]

Add2
Revolver1: [Patron(id, charged, 32), nil, nil, nil, nil, nil]
Revolver2: [nil, nil, nil, nil, nil, nil]

3. Unique Patron in collection
Revolver1: [nil, nil, nil, nil, nil, nil]
Revolver2: [nil, nil, nil, nil, nil, nil]

[Patron(id, charged, 32), Patron(id1, charged, 32), Patron(id2, charged, 32)]
[Patron(id, charged, 32), Patron(id3, charged, 32), Patron(id4, charged, 32)]

Add1 # call add for 1 st collection

Add2 
Revolver1: [Patron(id, charged, 32), Patron(id1, charged, 32), Patron(id2, charged, 32), nil, nil, nil]
Revolver2: [Patron(id3, charged, 32), Patron(id4, charged, 32), nil, nil, nil, nil]
```

### Задание 3. Профиль игрока

В данном задании требуется создать объект для профиля игрока и реализовать паттерн `делегат` в виде присваивания объекта сервера классу игрока для поиска противника.

**Профиль игрока:**
Класс `Profile` должен содержать:
- ID при помощи `UUID`
- Никнейм
- Возраст
- Имя
- Револьвер
- Дата создания профиля в виде `String`
- Статус (`IN_PLAY` - в игре, `SEARCH` - в поиске, `IDLE` - в ожидании, `OFFLINE` - не в сети)
- Ссылка, которая будет формировать при помощи переменной `lazy var` по примеру `http://gameserver.com/${id}-${nickname}`

**Игровой сервер**
Класс `Server` будет описывать логику взаимодействия между игроками. Объект должен содержать следующее:
- Адрес сервера
- Список игроков на сервере (список `Profile`)

**Делегат сервера в профиле**
При построении архитектуры в IOS приложении не редким является использование паттерна `Делегат` для вызова части логики. Реализуем этот паттерн на примере вызова игроком поиска соперника.
Создай протокол `PlayerAction`, который опишет возможные действия игрока при взаимодействии с сервером. В нашем случае там будет описана функция `findOpponent`. 
Класс `Server` должен унаследовать протокол и реализовать эту функцию. Функция возвращает профиль найденного игрока.
Делегат сервера добавь в виде переменной `playerActionDelegate` класса `PlayerAction`, который будет вызывать запрос поиска противника.

**Проверка результата:** создай несколько объектов профилей с разным статусом и помести их на сервер. Создай свой профиль, который будет в режиме ожидания. Помести его также на сервер. 
Далее программа должна вызвать поиска оппонента и поменять статус игрока на `SEARCH`. Функция должна вернуть оппонента противника, с новым статусом `IN_PLAY` и поменять статус в профиле игрока.

_Пример вывода программы_
```
SearcherProfile:
Profile("coolpicker", IDLE)

ServerProfiles:
[Profile("super3228", IDLE), Profile("lrdxg", SEARCH), Profile("kmaw", IN_PLAY), Profile("aveelyr", SEARCH), Profile("coolpicker", IDLE)]

Start Search
SearcherProfile:
Profile("coolpicker", SEARCH)
ServerProfiles:
[Profile("super3228", IDLE), Profile("lrdxg", SEARCH), Profile("kmaw", IN_PLAY), Profile("aveelyr", SEARCH),  Profile("coolpicker", SEARCH)]

Result Search
SearcherProfile:
Profile("coolpicker", SEARCH)
Opponent:
Profile("lrdxg", SEARCH)
ServerProfiles:
[Profile("super3228", IDLE), Profile("lordyxD", IN_PLAY), Profile("kmaw", IN_PLAY), Profile("aveelyr", SEARCH),  Profile("coolpicker", IN_PLAY)]
```

### Бонусное задание 4. Виды вооружений
Требуется реализовать различные классы оружия для игроков. В предыдущих заданиях ты уже сделал объекты револьвера и профиля игрока. Теперь добавим разнообразия для игры.

Протокол оружия `Weapon` должен содержать:
- название
- урон (от 0 до 100) от одного удара
- метод нанесения урона `shoot()`. Данный метод должен иметь возвращаемое значение Any.

Профиль игрока теперь должен содержать оружие типа `Weapon`.

**Револьвер**
Класс револьвера `Revolver` должен наследоваться от `Weapon`.  Определите урон в зависимости от калибра патрона (калибр = количеству урона). 

Создадим еще два типа оружия - нож `Knife` и винтовка `Riffle`. 

**Винтовка**
Класс `Riffle` схож по функционалу с револьвером. Однако винтовку необходимо каждый раз перезаряжать, добавляя патрон, так как обойма может содержать только одну пулю. Механизм добавления пуль в обойму аналогичен револьверу. Патроны для винтовки также имеют тип `Patron`.
**Нож**
- При вызове `shoot()` программа выводит `Crrr!`
  

**Проверка результата:** 
- Создай оружия трех типов: револьвер (обойма должна быть пустой), винтовка(магазин должен быть пустым) и нож.
- Проверь логику добавления патронов в `Revolver` и `Riffle`. В случае револьвера, предварительно прокрути обойму револьвера.
- Выведи урон оружий с разными патронами. Чем больше габарит, тем больший урон должен наноситься пулей.
- При ударе ножом должно быть выведено `Crrr!` и количество урона. 


_Пример вывода программы_
```
Knife("knife butterfy", 10)
Revolver("Revolver", 20)
Riffle("AWP", 88)

Knife shoot
Crrr! 10

Revolver Calibre 20

Add elements: [Patron(id, сharged, 10), Patron(id1, damp 20), Patron(id2, damp, 20), Patron(id3, damp, 20)]
Result adding: [Patron(id1, damp 20), Patron(id2, damp, 20), Patron(id3, damp, 20)]

Scrolling:  [Patron(id2, charged, 20), Patron(id3, damp, 20), Patron(id1, damp 20)]
Shoot: 
Bang 20


Riffle Calibre 50
Add element: Patron(id, damp, 50)
Shoot: 
Click
```


### Бонусное задание 5. Хороший, плохой, злой

В объекте сервера необходимо описать логику боя:
- Метод `fight()`, дополненный в протоколе `PlayerAction`. Данный метод должен возвращать true, если победил игрок, false - победил противник или ничья.
- Сам бой проходит со случайным порядком действия. Ты должен определять, кто бьет, следующим случайным образом. На старте у игроков по 100 единиц здоровья. Каждый удар отнимает единицы здоровья в соответствии с уроном оружия. В тот момент, когда у одного из игроков становится 0 единиц и меньше, игра заканчивается. Победителем становится игрок c положительными единицами здоровья.
- При каждом ударе должно печататься текущее состояние боя в виде строки никнеймов бойцов и их здоровья, а также количество нанесенного урона. Например, «Player 1 shoot Player1 90 - 80 Player2».
- Для револьвера должны перед игрой быть созданы 12 патронов. Патроны генерируются сервером. С вероятностью 50% пуля может быть холостой. 6 пуль добавляют в револьвер перед началом игры. В момент, когда эти пули заканчиваются, в револьер добавляются остальные 6.
- Для винтовки должны перед игрой быть созданы 4 патрона. Патроны генерируются сервером. С вероятностью 50% пуля может быть холостой. После каждого выстрела в винтовку добавляют новую пулю.
- Если патроны закончились, то игрок больше не может атаковать.
- Если у обоих игроков закончились патроны и они остались вживых, то игра завершается ничьей.
- Действия, связанные с добавлением патронов и прокруткой обоймы сопроводите информационным сообщением. Например, «Player1 scrolling»

**Проверка результата:** 
- Создай 2 игроков с различным типом оружия.
- Проверь, что в ходе боя наносится соответствующее оружию количество урона и правильно отображается текущее состояние здоровья игроков.

_Пример вывода программы_
```
MyProfile nickname - "coolpicker", weapon - knife, damage - 10
Opponent nickname - "lrdxg", weapon - revolver, calibre - 35, damage - 35

lrdxg scrolling

Fight!

coolpicker 100 - 100 lrdxg

coolpicker shoot
Crrr! 10
coolpicker 100 - 90 lrdxg

coolpicker shoot
Crrr! 10
coolpicker 100 - 80 lrdxg

lrdxg shoot
Click
coolpicker 100 - 80 lrdxg

lrdxg shoot
Click
coolpicker 100 - 80 lrdxg

lrdxg shoot
Bang 35
coolpicker 65 - 80 lrdxg

lrdxg shoot
Click
coolpicker 65 - 80 lrdxg

lrdxg shoot
Click
coolpicker 65 - 80 lrdxg

lrdxg shoot
Click
coolpicker 65 - 80 lrdxg

lrdxg drum is empty
lrdxg adding elements
lrdxg scrolling

lrdxg shoot
Bang 35
coolpicker 30 - 80 lrdxg


lrdxg shoot
Bang 35
coolpicker 0 - 80 lrdxg

You LOSE

lrdxg winner
```
