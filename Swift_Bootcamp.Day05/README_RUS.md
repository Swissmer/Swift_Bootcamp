### Привет!

В сегодняшнем проекте рассматривается тема асинхронных операций в Swift и IOS приложениях. 

Асинхронные операции важны в iOS приложениях, потому что они позволяют выполнять длительные задачи в фоновом режиме,
не блокируя основной поток.

Основной поток в iOS отвечает за обновление пользовательского интерфейса и взаимодействие с пользователем. 
Если выполняется длительная задача в основном потоке, 
это может вызвать временные задержки пользовательского интерфейса и привести к плохому пользовательскому опыту.

Выполняя длительные задачи асинхронно, гарантируется, 
что основной поток остается свободным для обработки обновлений пользовательского интерфейса 
и взаимодействия с пользователем, что приводит к отзывчивому и гладкому пользовательскому опыту.

Основными фреймворками для асинхронной разработки в iOS являются Combine и SwiftRx.
SwiftRx обладает лучшей обратной совместимостью, поэтому в курсе рассматривается именно он.

## Темы
- async-await
- конструкции SwiftRx(Observable, Single и другие)

## Проект: асинхронные операции 

## Задание:

**Создание проекта с зависимостями**
Для добавления зависимостей в проект ты можешь использовать Swift Packet Manager, встроенный в XCode, 
либо менеджер зависимостей [Cocoapods](https://cocoapods.org/).
Для создания проекта cocoapods воспользуйтесь инструкцией на сайте проекта, связанной с командами `pod`.

Примеры проект с SPM и CocoaPods ты можешь найти в папке `code-samples`. 
В проекте с cocoapods необходимо предварительно вызвать команду `pod install`.

**Требование!** Создай workspace внутри папки src с названием day05, если используешь Swift Packet Manager.
При использовании Cocoapods воспользуйтесь сгенерированным workspace после команды `pod install`
Для каждой задачи внутри workspace необходимо создать macOS/Command Line Tool проект. Например, day05/quest1, day05/quest2.
Также не забудь при создании проекта в пункте `Add to:` выбрать созданный workplace.
Более подробное описание о создании проектов можно прочитать в [документации](https://www.swift.org/getting-started/).

**Совет** Перед выполнением задания посмотри примеры асинхронной работы в документации [SwiftRx](https://github.com/ReactiveX/RxSwift/tree/main/Documentation)
и [Swift Concurrency](https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html).
Для установки зависимости SwiftRx в проект используй [CocoaPods](https://guides.cocoapods.org/)
или [Swift Packet Manager](https://www.swift.org/package-manager/)

**Требования к функциям**:
1. Все реализованные функции должны быть вызваны хотя бы 1 раз в функции main с применением `await`
2. В качестве входных данных для каждой функции выступают `firstCollection` и `secondCollection` из примера.
3. В случае, если функция применяется к `firstCollection` - входным параметром является Observable из строк,
а если к `secondCollection` - входным параметром является Observable из `Sample`.

### Задание 1

- Реализовать функцию, которая будет фильтровать `firstCollection` и сохранять только строки, где есть буква `e`

### Задание 2

- Реализовать функцию, которая будет возвращать первый элемент из `firstCollection`, начинающийся на `th`

### Задание 3

- Реализовать функцию, проверяющую все ли строки из `firstCollection` длиннее `5` символов

### Задание 4

- Реализовать функцию, проверяющую присутствуют ли строки длиннее `5` символов в `firstCollection`

### Задание 5

- Реализовать функцию, проверяющую отсутствие пустых строк в `firstCollection`

### Задание 6

- Реализовать функцию, считающую общую длину строк в `firstCollection`

### Задание 7

- Реализовать функцию, считающую количество строк в `firstCollection`

### Задание 8

- Реализовать функцию, возвращающую массив строк (полей text) из `secondCollection`

### Задание 9

- Реализовать функцию, группирующую значения по id в `secondCollection`

### Задание 10

- Реализовать функцию, группирующую значения по id в `secondCollection` и считающую количество элементов в каждой группе. 
Пример вывода listOf(Pair(1, 2), Pair(2, 2), Pair(3, 1)
