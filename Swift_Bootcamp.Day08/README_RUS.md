### Всем привет!

Цель - знакомство с паттерном DI в iOS. 
Для работы необходима библиотека [SwiInject](https://github.com/Swinject/Swinject).

## Темы
- DI
- Swinject
  
### Проект: DI в приложении
Dependency Injection (DI) - это паттерн проектирования программного обеспечения, который позволяет управлять зависимостями компонентов приложения, разделить ответственность, улучшить тестируемость и облегчить поддержку кода.

Когда приложение создает объекты, которые зависят от других объектов, 
это может привести к проблемам при их изменении и сложностям при тестировании. 
DI позволяет абстрагировать создание объектов от их использования, внедрять зависимости из внешних источников и управлять жизненным циклом объектов.

Напиши программу, которая будет состоять из заглушечных классов, имитирующих выполнение запросов и методов сохранения данных в базу (т.е. объекты не работают с сетью и базой данных, а лишь возвращают заранее определённые в коде объекты)

## Задания

**Требование!** Создай workspace внутри папки src с названием day08, если используешь Swift Packet Manager.
При использовании Cocoapods воспользуйтесь сгенерированным workspace после команды `pod install`
Для каждой задачи внутри workspace необходимо создать macOS/Command Line Tool проект. Например, day08/quest1, day08/quest2.
Также не забудь при создании проекта в пункте `Add to:` выбрать созданный workplace.
Более подробное описание о создании проектов можно прочитать в [документации](https://www.swift.org/getting-started/).

### Задание 0. Создать новый проект в XCode

### Задание 1. Подготовка объектов для DI

Для подготовки необходимо:
 - Создать класс данных `User`, содержащий не менее четырех полей
 - Создать протокол `NetworkService`, у которого есть метод для получения списка объектов `User`
 - Реализовать протокол `NetworkService` с именем класса `NetworkServiceImpl`, который возвращает заглушечный список заранее определенных объектов (список заполненных объектов можно создать прямо в методе получения)
 - Создать протокол `DatabaseService`, у которого есть метод для сохранения списка объектов `User`
 - Реализовать протокол `DatabaseService` с именем класса `ReleaseDatabaseServiceImpl`, который при сохранении выводит список в консоль «Release: [user1, user2, ... , userN] were saved»
- Реализовать протокол `DatabaseService` с именем класса `DebugDatabaseServiceImpl`, который при сохранении выводит список в консоль «Debug: [user1, user2, ... , userN] were saved»
- Реализовать `UserRepository` с методом для обновления данных о пользователях, в котором используются `NetworkService` и `DatabaseService`. `NetworkService` возвращает данные, `DatabaseService` сохраняет данные

### Задание 2. DI Swinject

**Совет:** Перед выполнением задания посмотри построения DI от [SwiInject](https://github.com/Swinject/Swinject) в их репозитории.

Все дальнейшие действия необходимо проделать в функции **main**. Каждый пункт является отдельной функцией, которая вызывается в **main**.

1. Получение объекта `UserRepository` с использованием фабричного метода:
  - Создай `Container`
  - Зарегистрируй в нем `NetworkService` с реализацией `NetworkServiceImpl`
  - Зарегистрируй в нем `DatabaseService` с реализацией `ReleaseDatabaseServiceImpl`
  - Зарегистрируй в нем `UserRepository` с существующими в `Container` `NetworkService` и `DatabaseService`
  - Получи объект `UserRepository` из `Container` и вызови метод для обновления данных о пользователе
  - Получи еще один `UserRepository` из `Container`
  - Сравни два полученных объекта `UserRepository` и результат выведи в консоль
2. Получение объекта `UserRepository` с использованием именнованных зависимостей:
  - Создай `Container`
  - Зарегистрируй в нем `NetworkService` с реализацией `NetworkServiceImpl`
  - Зарегистрируй в нем `DatabaseService` с реализацией `ReleaseDatabaseServiceImpl` и именем **release**
  - Зарегистрируй в нем `DatabaseService` с реализацией `DebugDatabaseServiceImpl` и именем **debug**
  - Зарегистрируй в нем `UserRepository` с существующими в `Container` `NetworkService` и `DatabaseService` с именем **release**
- Зарегистрируй в нем `UserRepository` с существующими в `Container` `NetworkService` и `DatabaseService` с именем **debug** 
- Получи объект `UserRepository` с именем **release** из `Container` и вызови метод для обновления данных о пользователе
- Получи объект `UserRepository` с именем **debug** из `Container` и вызови метод для обновления данных о пользователе
3. Получение единственного экземпляра `UserRepository`:
- Создай `Container`
- Зарегистрируй в нем `NetworkService` с реализацией `NetworkServiceImpl`
- Зарегистрируй в нем `DatabaseService` с реализацией `ReleaseDatabaseServiceImpl`
- Зарегистрируй в нем `UserRepository` с существующими в `Container` `NetworkService` и `DatabaseService` с использованием **scope**, который создает синглтон (подходящий scope нужно найти в документации)
- Получи объект `UserRepository` из `Container` и вызови метод для обновления данных о пользователе
- Получи еще один `UserRepository` из `Container`
- Сравни два полученных объекта `UserRepository` и результат выведи в консоль

